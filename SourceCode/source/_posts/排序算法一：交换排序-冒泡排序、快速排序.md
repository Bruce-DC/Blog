---
title: '排序算法一：交换排序[冒泡排序、快速排序]'
date: 2020-12-18 11:42:38
tags: 算法
---
今天先介绍两种排序方式，冒泡排序和快速排序。在我看来它们都属于以交换值来达到排序目的的方法。交换排序的主要思路是在我们对某一序列进行排序的过程中，通过对序列中元素进行比较，发现它们的次序相反，就将它俩的值进行交换。
<!-- more -->
## 1 冒泡排序
冒泡排序在排序算法中是一种非常简单的排序方法。它的基本思想是对所有相邻的元素进行比较，逆序则交换。

太简单了就直接上代码吧：
```C#
class Program
{
    static void Main(string[] args)
    {
        int[] arr = new int[] { 8, 9, 4, 3, 5, 7, 6, 2, 1 };
        if (arr == null || arr.Length == 0)
            return;
        //最大的值放在最后，最后的元素就不用参与排序了
        for (int i = 1; i < arr.Length; i++)
        {
            //从前往后走
            for (int j = 0; j < arr.Length - i; j++)
            {
                if (arr[j] > arr[j + 1])
                {
                    Swap(arr, j, j + 1);
                }
            }
        }
        //最终在控制台输出数组
        for (int i = 0; i <= arr.Length - 1; i++)
        {
            Console.Write(arr[i]);
        }
        Console.ReadKey();
    }
    //简单的交换方法
    static void Swap(int[] arr, int i, int j)
    {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```
冒泡排序适用于基本有序的序列，这样他的效率会更高，反之，序列越乱，效率越低下！时间复杂度为O(n²)。

代码不能只看，还要手敲，手上敲，嘴里碎碎念，敲完一遍已经理解的八九不离十了。

## 2 快速排序
冒泡排序效率低下的原因在于它在排序过程中，互换相邻的元素只能消除一个逆序，如果说通过交换可以消除多个逆序的话，那么效率将会大大提高。这就是快速排序的特性之一，只不过它交换的不是相邻元素，而是不相邻的元素。

快速排序的基本思想是从序列中选取一个合适的值作为基准值。比基准值大的元素放在基准值右侧，比基准值小的元素放在基准值左侧，这样一个完整的序列就将被分为两个序列，然后再对两个序列进行同样的操作，接着划分成两个子序列，直到子序列的长度为1。
```C#
class Program
{
    static void Main(string[] args)
    {
        int[] arr = new int[] { 8, 9, 4, 3, 5, 7, 6, 2, 1 };
        QuickSort(arr, 0, arr.Length - 1);

        for (int i = 0; i <= arr.Length - 1; i++)
        {
            Console.Write(arr[i]);
        }
        Console.ReadKey();

    }
    public static void QuickSort(int[] arr, int low, int high)
    {
        if (low < high) //确保数组里的元素多余1
        {
            int i = low;
            int j = high;
            int temp = arr[i];

            while (i < j)
            {
                while (itemp) //从右侧扫描，找到比基准值小的，放在左侧，先不要管基准值放在哪里
                {
                    j--;
                }

                arr[i] = arr[j]; //走到这里，说明找到了比基准值小的，先放在左侧，右侧先不用管
                while (i < j && arr[i] < temp) //从左侧扫描，找到比基准值大的，放在右侧
                {
                    i++;
                }
                arr[j] = arr[i];
            }
            arr[i] = temp; //走到这里说明当前层次已经基本排好序了，可以对子序列再进行排序了，这个时候i走到了应该的位置， 把基准值放在这里。
            QuickSort(arr, low, i - 1);
            QuickSort(arr, i + 1, high);
        }

    }
```

代码呀，不能大眼瞪小眼看，亲手敲一遍才能真正记到心里！